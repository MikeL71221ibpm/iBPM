import express, { type Request, Response, NextFunction } from "express";
import { registerRoutes } from "./routes";
import { setupVite, serveStatic, log } from "./vite";
import emergencyRouter from "./api-emergency";
import emergencyDirectDbRouter from "./emergency-direct-db";
// Import working V3.3.5 stall monitor
import { stallMonitor } from './stall-monitor.js';
import { DatabaseStorage } from './database-storage';
import { WebSocketServer } from 'ws';
import { createServer } from 'http';

// Auto-restart disabled for production deployment
async function checkAndRestartIncompleteExtractions() {
  console.log(`⚠️ Auto-restart system disabled - manual extraction start required if needed`);
}

const app = express();

// Special handling for Stripe webhooks - needs raw body for signature verification
app.use('/api/webhook', express.raw({ type: 'application/json' }));

// Regular JSON parsing for other routes
app.use(express.json());
app.use(express.urlencoded({ extended: false }));
app.use(express.static("client/public"));

// Emergency test page route
app.get('/emergency-test', (req, res) => {
  console.log('Serving emergency test page...');
  res.sendFile('emergency-test.html', { root: './client' });
});

// Register emergency recovery routes
app.use('/api/emergency', emergencyRouter);

// Register direct database emergency routes
app.use('/api', emergencyDirectDbRouter);

// Import the real file info API implementation
import { getFileInfo } from "./file-info-api";

// Add file info endpoint to get current file information from database
app.get('/api/file-info', getFileInfo);

app.use((req, res, next) => {
  const start = Date.now();
  const path = req.path;
  let capturedJsonResponse: Record<string, any> | undefined = undefined;

  const originalResJson = res.json;
  res.json = function (bodyJson, ...args) {
    capturedJsonResponse = bodyJson;
    return originalResJson.apply(res, [bodyJson, ...args]);
  };

  res.on("finish", () => {
    const duration = Date.now() - start;
    if (path.startsWith("/api")) {
      let logLine = `${req.method} ${path} ${res.statusCode} in ${duration}ms`;
      if (capturedJsonResponse) {
        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
      }

      if (logLine.length > 80) {
        logLine = logLine.slice(0, 79) + "…";
      }

      log(logLine);
    }
  });

  next();
});

(async () => {
  const server = await registerRoutes(app);

  app.use((err: any, _req: Request, res: Response, _next: NextFunction) => {
    const status = err.status || err.statusCode || 500;
    const message = err.message || "Internal Server Error";

    res.status(status).json({ message });
    throw err;
  });

  // importantly only setup vite in development and after
  // setting up all the other routes so the catch-all route
  // doesn't interfere with the other routes
  if (app.get("env") === "development") {
    await setupVite(app, server);
  } else {
    serveStatic(app);
  }

  // ALWAYS serve the app on port 5000
  // this serves both the API and the client.
  // It is the only port that is not firewalled.
  // Create HTTP server from Express app
  const httpServer = createServer(app);
  
  // Setup WebSocket server for real-time progress updates
  const wss = new WebSocketServer({ server: httpServer });
  const clients = new Map<number, any>(); // Map userId to WebSocket client
  
  wss.on('connection', (ws) => {
    console.log('👤 WebSocket client connected');
    
    ws.on('message', (message) => {
      try {
        const data = JSON.parse(message.toString());
        if (data.type === 'identify' && data.userId) {
          clients.set(data.userId, ws);
          console.log(`📡 Client identified: User ${data.userId}`);
        }
      } catch (error) {
        console.error('WebSocket message error:', error);
      }
    });
    
    ws.on('close', () => {
      // Remove client from map when disconnected
      for (const [userId, client] of Array.from(clients.entries())) {
        if (client === ws) {
          clients.delete(userId);
          console.log(`📡 Client disconnected: User ${userId}`);
          break;
        }
      }
    });
  });

  // Export function to broadcast progress updates
  (global as any).broadcastProgress = (userId: number, data: any) => {
    const client = clients.get(userId);
    if (client && client.readyState === 1) { // WebSocket.OPEN
      client.send(JSON.stringify({
        type: 'extraction_progress',
        progress: data.progress,
        status: data.status,
        message: data.message,
        timestamp: new Date().toISOString()
      }));
      console.log(`📊 Sent progress to User ${userId}: ${data.progress}% (${data.status})`);
    } else {
      console.log(`⚠️ No WebSocket client found for User ${userId} or connection closed`);
    }
  };
  
  const port = 5000;
  httpServer.listen(port, "0.0.0.0", () => {
    log(`serving on port ${port}`);
    
    // DISABLED: Auto-restart system disabled to prevent blank white page issue
    // The auto-restart was resetting completed processing status back to pending
    console.log("⚠️ Auto-restart system disabled - manual extraction start required if needed");
    
    // Add process monitoring to catch termination causes
    process.on('exit', (code) => {
      console.log(`🚨 SERVER PROCESS EXITING with code: ${code}`);
      console.trace('Exit stack trace:');
    });
    
    process.on('SIGTERM', () => {
      console.log('🚨 SERVER RECEIVED SIGTERM');
      console.trace('SIGTERM stack trace:');
    });
    
    process.on('SIGINT', () => {
      console.log('🚨 SERVER RECEIVED SIGINT');
      console.trace('SIGINT stack trace:');
    });
    
    process.on('uncaughtException', (error) => {
      console.error('🚨 UNCAUGHT EXCEPTION:', error);
      console.trace('Exception stack trace:');
    });
    
    process.on('unhandledRejection', (reason, promise) => {
      console.error('🚨 UNHANDLED REJECTION at:', promise, 'reason:', reason);
      console.trace('Rejection stack trace:');
    });
    
    console.log('✅ Process monitoring enabled - will track termination causes');
  });
})();
